Implementing Transitions
------------------------

Finite state machines normally have an input stream that modifies the
internal state as fast as new signals arrive. This can lead to very fast
state switching, but to maintain the parallelism, transform oriented
finite state machines only run one update based on all signals available
at the time of the tick. There is no ambiguity however, as if there are
more than one conditional responses matching the input state, then it is
fine to go to more than one state at once as a result.

Consider the finite state machine in a point and click adventure, where
the character has to find three objects. In most games, the logic would
be defined as a state waiting for all objects to be found. In a
condition table finite state machine, there could be three different
tables representing each of the objects, and while any table is
populated, the game will not progress.

In a transform oriented finite state machine, the transitions are
generated by the condition tables transforming the input signals into
table insertions and deletions. Whenever a condition is matched, it
emits an entity ID and a bool into a transition table (or a null if you
intend to reduce the table in a separate process) ready for processing
in the commit stage. This means that a finite state machine can react to
multiple signals in a deterministic way because the state will not
change before it has finished processing all the possible condition
matches. There is no inherent temporal coupling in this design.
Traditional finite state machines donâ€™t allow for multiple reactions at
once as they transition from one state to another, naturally reacting on
the order of signals, which is perfect for a finite state machine built
for a lexer or parser, but possibly not for a generic gameplay state
machine.

